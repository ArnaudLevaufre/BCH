\documentclass[a4paper, 11pt, svgnames]{report}
\usepackage[margin=3cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{hyperref}
\usepackage[toc,acronym,nopostdot]{glossaries}
\usepackage{graphicx}
\usepackage{float}
\usepackage{minted}
\usepackage{mathtools}
\usepackage[toc, page]{appendix}
\usepackage{subcaption}
\usepackage{rotating}
\usepackage{pst-circ}

\usepackage{tikz}
\usetikzlibrary{decorations.text, arrows, arrows.spaced ,automata, snakes, circuits.logic.US, calc, shapes.geometric}

\tikzstyle{block} = [draw]
\tikzstyle{asyncblock} = [draw]


\input{./components.tex}
%
% Glossaries
%

\makeglossaries

%
% Document
%

\title{Décodeur BCH}
\author{Ronan~\bsc{Le Guillou} \and Arnaud~\bsc{Levaufre} \and Bastien~\bsc{Orivel}}

\begin{document}
    \maketitle
    \tableofcontents
    \printglossaries
    \listoffigures
    \listoftables

    \chapter{Introduction}

    Ce rapport présente le travail de conception et d'implémentation d'un
    décodeur BCH réalisé dans le cadre du mini projet du cours de conception
    sur puce de l'Enib.

    \paragraph{}
    Le décodeur BCH demandé doit être capable de détecter jusqu'à cinq erreurs
    et d'en corriger au plus deux. Le décodeur travaille sur des données codées
    sur 21 bits et utilise 10 bits de redondance. Les parties données et bits de
    redondance forment un mot de 31 bits auquel on ajoute un bit 0 en poid fort
    pour former un mot de 32 bits. Le décodeur doit implémenter une interface
    avalon le rendant compatible avec le processeur NiosII. Les communications
    entre le décodeur et le processeur se fait par quatres registres: les
    registres de status, de contrôle, de donnée d'entrée et de sortie. Ces
    registres ont un format de 32 bits.

    \paragraph{}
    Pour la lecture de ce rapport, il est important de noter plusieurs points
    sur les schémas fonctionnels présentés. La connexion entre deux cables
    croisés est représenté par un points. Deux cables croisés sans points ne se
    connectent pas. Les entrées d'horloge et de reset sont présents sur les
    blocks qui en ont besoins mais ne sont pas cablés sur les schémas pour
    faciliter la lecture. Toute entrée reset et Clk est par défaut et sauf
    indication contraire, considéré comme reliée à l'horloge et au reset
    maitre. Les cas particuliers sont explicités.

    \chapter{Étude du circuit}
        \section{Architecture globale}
        La vue extérieur du décodeur BCH est imposée par le sujet et est
        présentée dans la figure~\ref{fig:bch} ci-dessous. Sa structure
        interne est présentée dans la subsection~\ref{sec:fonc_bch}. On
        retrouve les entrées et sorties nécéssaires pour définir une
        interface Avalon fonctionnelle.

            \begin{figure}[H]
                \centering
                \begin{tikzpicture}[>=stealth,scale=1, every node/.style={scale=1}, circuit logic US]
                    \tikzstyle{every initial by arrow} = [initial text=reset, text=red, -, draw=red, decorate, decoration=zigzag]
                    \node[shape=bch] (bch) {BCH};

                    \draw[<-, double] (bch.Din) -- +(-1, 0) node[anchor=east] {Din};
                    \draw[<-] (bch.Wr) -- +(-1, 0) node[anchor=east] {Wr};
                    \draw[<-] (bch.Rd) -- +(-1, 0) node[anchor=east] {Rd};
                    \draw[<-] (bch.Addr) -- +(-1, 0) node[anchor=east] {Addr};
                    \draw[<-] (bch.Resetn) -- +(-1, 0) node[anchor=east] {Reset\_n};
                    \draw[->, double] (bch.Dout) -- +(1, 0) node[anchor=west] {Dout};
                    \draw[->] (bch.Irqn) -- +(1, 0) node[anchor=west] {Irq\_n};

                \end{tikzpicture}
                \caption{Vue éxtérieur du block BCH}
                \label{fig:bch}
            \end{figure}

            \subsection{Sous ensembldes fonctionnels du block BCH}
            \label{sec:fonc_bch}
            La réalisation du décodeur BCH se base sur cinq blocks
            présentés dans les subsections suivantes.
            \begin{itemize}
                \item Le calcul du syndrome.
                \item La look up table.
                \item Le correcteur d'erreur.
                \item L'interface avalon.
                \item La machine a état maitre.
            \end{itemize}
            A l'exception de l'interface avalon et de la machine à état, les
            blocs sont relativement indépendants et peuvent être utilisés
            chacun séparément. Cela facilite, d'une part, le développement et
            le test, et d'autre part, la réutilisation du code développé. Un
            codeur BCH pourrait par exemple réutiliser le block de calcul du
            syndrome. La figure~\ref{fig:bch_blocks}

            \begin{figure}[H]
                \centering
                \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=4cm, scale=0.75, every node/.style={scale=0.75}]
                    \tikzstyle{every initial by arrow} = [initial text=reset, text=red, -, draw=red, decorate, decoration=zigzag]
                    \tikzstyle{connectionpoint} = [circle, draw, fill=black, scale=0.5];
                    %\draw[help lines] (0, 0) grid (20,20);

                    \node[shape=avalon] at (0, 0) (avalon) {Avalon};
                    \node[shape=memaster] at (7.25, 10) (memaster) {ME\_Master};
                    \node[shape=syndrome] at (15, 15) (syndrome) {Syndrome};
                    \node[shape=lut] at (15, 10) (lut) {Lut};
                    \node[shape=corr] at (15, 5) (corr) {Correcteur};
                    \node[shape=dff] at (8, 5) (dff) {Err};

                    \draw[->] (memaster.StartSyndrome) -- +(0.25, 0) |- (syndrome.Start);
                    \draw[->] (memaster.StartLut) -- +(0.25, 0) |- (lut.Start);
                    \draw[->] (memaster.StartCorr) -- +(1.25, 0) |- (corr.Start);
                    \draw[->] (corr.End) -- +(1.5, 0) -- +(1.5, 13) -- +(-15, 13) |- (memaster.EndCorr);
                    \draw[->] (lut.End) -- +(1.25, 0) -- +(1.25, 7.25) -- +(-14.75, 7.25) |- (memaster.EndLut);
                    \draw[->] (syndrome.End) -- +(1, 0) -- +(1, 3.75) -- +(-14.5, 3.75) |- (memaster.EndSyndrome);
                    \draw[->, double] (syndrome.Syndrome) -- +(0.75, 0) -- +(0.75, 2) -- +(-14.25, 2) |- (memaster.Syndrome);
                    \draw[->, double] (syndrome.Syndrome) -- +(0.75, 0) node[connectionpoint] {} -- +(0.75, -3) -- +(-5.5, -3) |- (lut.Syndrome);
                    \draw[->, double] (lut.Err) -- +(0.5, 0) |- +(-11, -1.75) |- (dff.D);
                    \draw[->, double] (dff.Q) -- +(1,0) |- (corr.Err);
                    \draw[->] (lut.LdErr) -- +(0.25, 0) |- +(-11.5, -0.75) -- +(-11.5, -5.5) -| (dff.S);
                    \draw[->] (memaster.RazErr) -| +(0.25, -0.5) -| (dff.R);
                    \draw[->] (lut.Pone) -| +(1, -3.75) -- +(-5.5, -3.75) |- (corr.Pone);
                    \draw[->] (lut.Ptwo) -| +(0.75, -2.75) -- +(-5.75, -2.75) |- (corr.Ptwo);

                    \draw[->] (memaster.AskIrq) -- +(0.5, 0) |- (avalon.AskIrq);
                    \draw[->, double] (corr.Dout) -- +(1, 0) |- (avalon.CorrOut);
                    \draw[->] (corr.End) -- +(1.5, 0) node[connectionpoint] {} |- (avalon.CorrOutLd);

                    \draw[->, double] (avalon.FifoOut) -- +(9, 0) |- (corr.Din);
                    \draw[->, double] (avalon.FifoOut) -- +(1, 0) node[connectionpoint] {} -| +(1, 4) -| +(-2, 4) |- (syndrome.Data);
                    \draw[->, double] (avalon.Words) -| +(1.5, 5.25) -| +(-1.5, 5.25) |- (memaster.Words);
                    \draw[->] (avalon.Decode) -| +(2, 6.5) -| +(-1, 6.5) |- (memaster.Decode);

                    \draw (avalon.FifoOut) +(0,0) node [anchor=south west]  {32};
                    \draw (avalon.Words) +(0,0) node [anchor=south west] {5};
                    \draw (dff.Q) +(0,0) node [anchor=south west] {2};
                    \draw (corr.Dout) +(0,0) node [anchor=south west] {32};
                    \draw (lut.Err) +(0,0) node [anchor=south west] {2};
                    \draw (syndrome.Syndrome) +(0,0) node [anchor=south west] {10};

                \end{tikzpicture}
                \caption{Vue intérieure du block BCH}
                \label{fig:bch_blocks}
            \end{figure}

            \subsection{Machine à état principale}
            \begin{figure}[H]
                \centering
                \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=4cm, scale=0.75, every node/.style={scale=0.75}]
                    \tikzstyle{every initial by arrow} = [initial text=reset, text=red, -, draw=red, decorate, decoration=zigzag]
                    %\draw[help lines] (0, 0) grid (10,10);

                    \node[state, accepting, initial above ] at (5, 10) (E1){Iddle};
                    \node[state] at (10, 5) (E2){Syndrome};
                    \node[state] at (5, 0) (E3){LUT};
                    \node[state] at (0, 5) (E4){Correction};

                    \path[->] (E1) edge [loop below] node {!decode} (E1);
                    \path[->] (E1) edge [bend left] node {decode / start\_syndrome} (E2);

                    \path[->] (E2) edge [loop right] node {!end\_syndrome} (E2);
                    \path[->] (E2) edge [bend left] node {end\_syndrome . syndrome != 0 / start\_lut} (E3);
                    \path[->] (E2) edge [bend left] node {end\_syndrome . syndrome = 0 / raz\_err, start\_corr} (E4);

                    \path[->] (E3) edge [loop below] node {!end\_lut} (E3);
                    \path[->] (E3) edge [bend left] node {end\_lut / start\_corr} (E4);

                    \path[->] (E4) edge [loop left] node {!end\_corr} (E4);
                    \path[->] (E4) edge [bend left] node {end\_corr . words = 0 / ask\_irq} (E1);
                    \path[->] (E4) edge [bend left] node {end\_corr . words > 0} (E2);


                \end{tikzpicture}
                \caption{Machine à état globale}
                \label{fig:me_syndrome}
            \end{figure}


        \section{Calcul du syndrome}
            Le calcul du syndrome est décomposé en une unité de traitement et
            une unité de contrôle qui sont présentées dans les
            sections~\ref{sec:ut_syndrome} et \ref{sec:uc_syndrome}. Le
            principe de fonctionnement est simple, l'utilisateur de ce bloc
            propose une donnée codée sur 32 bits sur l'entrée «~Data~» et
            démarre le calcul en imposant l'entrée «~Start~» à 1.  Une fois
            calculé, le syndrome est disponible sur la sortie «~Syndrome~» et le
            drapeau «~End~» est passé à 1 sur une durée d'une période
            d'horloge.

            \subsection{Unité de traitement}
            \label{sec:ut_syndrome}

            L'unité de traitement est présentée en figure~\ref{fig:ut_syndrome}
            et reprend le schéma du sujet en lui ajoutant le registre à
            décalage permettant de rentrer la donnée utilisateur bit par bit,
            poids faible en premier.

            \begin{figure}[H]
                \centering
                \begin{tikzpicture}[>=stealth,scale=0.375, every node/.style={scale=0.5}, circuit logic US]
                    %\draw[help lines] (0, 0) grid (29, 32);

                    \node[shape=dff] at (12, 30) (dff0) {0};
                    \node[shape=dff] at (12, 27) (dff1) {1};
                    \node[shape=dff] at (12, 24) (dff2) {2};
                    \node[shape=dff] at (12, 21) (dff3) {3};
                    \node[shape=dff] at (12, 18) (dff4) {4};
                    \node[shape=dff] at (12, 15) (dff5) {5};
                    \node[shape=dff] at (12, 12) (dff6) {6};
                    \node[shape=dff] at (12, 9) (dff7) {7};
                    \node[shape=dff] at (12, 6) (dff8) {8};
                    \node[shape=dff] at (12, 3) (dff9) {9};

                    \node[circle,draw,fill=black,scale=0.3] at (9,24)  {};
                    \node[circle,draw,fill=black,scale=0.3] at (9, 18)  {};
                    \node[circle,draw,fill=black,scale=0.3] at (9, 15)  {};
                    \node[circle,draw,fill=black,scale=0.3] at (9, 9)  {};
                    \node[circle,draw,fill=black,scale=0.3] at (9, 6)  {};
                    \node[circle,draw,fill=black,scale=0.3] at (10.5, 28.7)  {};
                    \node[circle,draw,fill=black,scale=0.3] at (10.5, 28.7)  {};
                    \node[circle,draw,fill=black,scale=0.3] at (10.5, 25.7)  {};
                    \node[circle,draw,fill=black,scale=0.3] at (10.5, 22.7)  {};
                    \node[circle,draw,fill=black,scale=0.3] at (10.5, 19.7)  {};
                    \node[circle,draw,fill=black,scale=0.3] at (10.5, 16.7)  {};
                    \node[circle,draw,fill=black,scale=0.3] at (10.5, 13.7)  {};
                    \node[circle,draw,fill=black,scale=0.3] at (10.5, 10.7)  {};
                    \node[circle,draw,fill=black,scale=0.3] at (10.5, 7.7)   {};
                    \node[circle,draw,fill=black,scale=0.3] at (10.5, 4.7)   {};
                    \node[circle,draw,fill=black,scale=0.3] at (10.5, 1.7)   {};
                    \node[circle,draw,fill=black,scale=0.3] at (10, 31.3)   {};
                    \node[circle,draw,fill=black,scale=0.3] at (10, 28.3)   {};
                    \node[circle,draw,fill=black,scale=0.3] at (10, 25.3)   {};
                    \node[circle,draw,fill=black,scale=0.3] at (10, 22.3)   {};
                    \node[circle,draw,fill=black,scale=0.3] at (10, 19.3)   {};
                    \node[circle,draw,fill=black,scale=0.3] at (10, 16.3)   {};
                    \node[circle,draw,fill=black,scale=0.3] at (10, 13.3)   {};
                    \node[circle,draw,fill=black,scale=0.3] at (10, 10.3)   {};
                    \node[circle,draw,fill=black,scale=0.3] at (10, 7.3)    {};
                    \node[circle,draw,fill=black,scale=0.3] at (10, 4.3)    {};

                    \node[circle,draw,fill=black,scale=0.3] at (13, 30.5)    {};
                    \node[circle,draw,fill=black,scale=0.3] at (13, 27.5)    {};
                    \node[circle,draw,fill=black,scale=0.3] at (13, 24.5)    {};
                    \node[circle,draw,fill=black,scale=0.3] at (13, 21.5)    {};
                    \node[circle,draw,fill=black,scale=0.3] at (13, 18.5)    {};
                    \node[circle,draw,fill=black,scale=0.3] at (13, 15.5)    {};
                    \node[circle,draw,fill=black,scale=0.3] at (13, 12.5)    {};
                    \node[circle,draw,fill=black,scale=0.3] at (13, 9.5)     {};
                    \node[circle,draw,fill=black,scale=0.3] at (13, 6.5)     {};
                    \node[circle,draw,fill=black,scale=0.3] at (13, 3.5)     {};

                    \node[xor gate, rotate=-90, scale=1.5] at (9.5, 22) (x3) {};
                    \node[xor gate, rotate=-90, scale=1.5] at (9.5, 16) (x5) {};
                    \node[xor gate, rotate=-90, scale=1.5] at (9.5, 13) (x6) {};
                    \node[xor gate, rotate=-90, scale=1.5] at (9.5, 7) (x8) {};
                    \node[xor gate, rotate=-90, scale=1.5] at (9.5, 4) (x9) {};
                    \node[xor gate, rotate=90, scale=1.5] at (8, 28) (x10) {};

                    \node[shape=srr] at (5, 24) (synbuff) {};

                    \node[left] at (0, 26) (data) {Data $[~31:0~]$};
                    \node[left] at (0, 25) (ld) {Ld};
                    \node[left] at (0, 24) (calc) {Calc};
                    \node[right] at (19, 31.5) (syndrome) {Syndrome $[~9:0~]$};
                    \node[left] at (0, 23) (clear) {Clear} ;

                    \draw [->, double] (data) -- (2.5, 26) |- (synbuff.Din);
                    \draw [->] (ld) -- (2, 25) |- (synbuff.Ld);

                    \draw [->] (synbuff.Dout) -| (x10.input 1);
                    \draw [->] (x10.output) -- (8, 29) -- (9, 29) -- (9, 24) -| (x3.input 2);
                    \draw [->] (x10.output) -- (8, 29) -- (9, 29) -- (9, 24) -- (9, 18) -| (x5.input 2);
                    \draw [->] (x10.output) -- (8, 29) -- (9, 29) -- (9, 24) -- (9, 15) -| (x6.input 2);
                    \draw [->] (x10.output) -- (8, 29) -- (9, 29) -- (9, 24) -- (9, 9) -| (x8.input 2);
                    \draw [->] (x10.output) -- (8, 29) -- (9, 29) -- (9, 24) -- (9, 6) -| (x9.input 2);

                    \draw [->] (x10.output) |- (dff0.D);
                    \draw [->] (x9.output) |- (dff9.D);
                    \draw [->] (x8.output) |- (dff8.D);
                    \draw [->] (x6.output) |- (dff6.D);
                    \draw [->] (x5.output) |- (dff5.D);
                    \draw [->] (x3.output) |- (dff3.D);

                    \draw [->] (dff0.Q) -| (13, 28.5) -- (11, 28.5) |- (dff1.D);
                    \draw [->] (dff1.Q) -| (13, 25.5) -- (11, 25.5) |- (dff2.D);
                    \draw [->] (dff2.Q) -| (13, 22.5) -- (13, 22.5) -| (x3.input 1);
                    \draw [->] (dff3.Q) -| (13, 19.5) -- (11, 19.5) |- (dff4.D);
                    \draw [->] (dff4.Q) -| (13, 16.5) -- (13, 16.5) -| (x5.input 1);
                    \draw [->] (dff5.Q) -| (13, 13.5) -- (13, 13.5) -| (x6.input 1);
                    \draw [->] (dff6.Q) -| (13, 10.5) -- (11, 10.5) |- (dff7.D);
                    \draw [->] (dff7.Q) -| (13, 7.5) -- (13, 7.5) -| (x8.input 1);
                    \draw [->] (dff8.Q) -| (13, 4.5) -- (13, 4.5) -| (x9.input 1);
                    \draw [->] (dff9.Q) -| (13, 1.5) -- (11, 1.5) -| (x10.input 2);

                    \draw [->] (calc) -- (2, 24) -- (2, 21) -- (10.5, 21) -- (10.5, 28.7) -| (dff0.S);
                    \draw [->] (calc) -- (2, 24) -- (2, 21) -- (10.5, 21) -- (10.5, 25.7) -| (dff1.S);
                    \draw [->] (calc) -- (2, 24) -- (2, 21) -- (10.5, 21) -- (10.5, 22.7) -| (dff2.S);
                    \draw [->] (calc) -- (2, 24) -- (2, 21) -- (10.5, 21) -- (10.5, 19.7) -| (dff3.S);
                    \draw [->] (calc) -- (2, 24) -- (2, 21) -- (10.5, 21) -- (10.5, 16.7) -| (dff4.S);
                    \draw [->] (calc) -- (2, 24) -- (2, 21) -- (10.5, 21) -- (10.5, 13.7) -| (dff5.S);
                    \draw [->] (calc) -- (2, 24) -- (2, 21) -- (10.5, 21) -- (10.5, 10.7) -| (dff6.S);
                    \draw [->] (calc) -- (2, 24) -- (2, 21) -- (10.5, 21) -- (10.5, 7.7) -| (dff7.S);
                    \draw [->] (calc) -- (2, 24) -- (2, 21) -- (10.5, 21) -- (10.5, 4.7) -| (dff8.S);
                    \draw [->] (calc) -- (2, 24) -- (2, 21) -- (10.5, 21) -- (10.5, 1.7) -| (dff9.S);

                    \draw [->] (clear) -- (1, 23) -- (1, 20) -- (10, 20) -- (10, 31.3) -| (dff0.R);
                    \draw [->] (clear) -- (1, 23) -- (1, 20) -- (10, 20) -- (10, 28.3) -| (dff1.R);
                    \draw [->] (clear) -- (1, 23) -- (1, 20) -- (10, 20) -- (10, 25.3) -| (dff2.R);
                    \draw [->] (clear) -- (1, 23) -- (1, 20) -- (10, 20) -- (10, 22.3) -| (dff3.R);
                    \draw [->] (clear) -- (1, 23) -- (1, 20) -- (10, 20) -- (10, 19.3) -| (dff4.R);
                    \draw [->] (clear) -- (1, 23) -- (1, 20) -- (10, 20) -- (10, 16.3) -| (dff5.R);
                    \draw [->] (clear) -- (1, 23) -- (1, 20) -- (10, 20) -- (10, 13.3) -| (dff6.R);
                    \draw [->] (clear) -- (1, 23) -- (1, 20) -- (10, 20) -- (10, 10.3) -| (dff7.R);
                    \draw [->] (clear) -- (1, 23) -- (1, 20) -- (10, 20) -- (10, 7.3) -| (dff8.R);
                    \draw [->] (clear) -- (1, 23) -- (1, 20) -- (10, 20) -- (10, 4.3) -| (dff9.R);

                    \draw [->] (dff0.Q) -- (18, 30.5) node [above left](b0) {0};
                    \draw [->] (dff1.Q) -- (18, 27.5) node [above left](b1) {1};
                    \draw [->] (dff2.Q) -- (18, 24.5) node [above left](b2) {2};
                    \draw [->] (dff3.Q) -- (18, 21.5) node [above left](b3) {3};
                    \draw [->] (dff4.Q) -- (18, 18.5) node [above left](b4) {4};
                    \draw [->] (dff5.Q) -- (18, 15.5) node [above left](b5) {5};
                    \draw [->] (dff6.Q) -- (18, 12.5) node [above left](b6) {6};
                    \draw [->] (dff7.Q) -- (18, 9.5) node [above left](b7) {7};
                    \draw [->] (dff8.Q) -- (18, 6.5) node [above left](b8) {8};
                    \draw [->] (dff9.Q) -- (18, 3.5) node [above left](b9) {9};
                    \draw [->, double] (18, 3.5) |- (syndrome);

                \end{tikzpicture}
                \caption{Unité de traitement pour le calcul du syndrome}
                \label{fig:ut_syndrome}
            \end{figure}

            \subsection{Unité de contrôle}
            \label{sec:uc_syndrome}

            L'unité de controle utilisé pour le calcul du syndrome est définie
            par la machine à étât présenté en figure~\ref{fig:uc_syndrome_ext}
            et \ref{fig:me_syndrome}.  Elle se base sur un compteur afin
            d'autoriser le décalage et calcul du syndrome pendant les 31 coups
            d'horloge nécéssaire. Après les 31 coups d'horloge le résultat est
            conservé dans les registres permettants le calcul du syndrome. Il
            sera conservé jusqua la prochaine demande de calcul de syndrome,
            qui débutera par le chargement du registre à décalage avec les
            données issues de la pile et par la remise à zéro des registres de
            calculs du syndrome.

            \begin{figure}[H]
                \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=4cm]
                    \tikzstyle{every initial by arrow} = [text=red, -, draw=red, decorate, decoration=zigzag]
                    \node[state,accepting, initial, initial text=reset](E1){Repos};
                    \node[state](E2)[below of=E1]{Dec\_syn};

                    \path[->] (E1) edge [loop right] node {!start\_syndrome} (E1);
                    \path[->] (E1) edge node {start\_syndrome / ld\_syn\_buff, clear, syn\_dcpt=30} (E2);
                    \path[->] (E2) edge [loop right] node {syn\_dcpt != 0 / calc, syn\_dcpt -= 1} (E2);
                    \path[->] (E2) edge [bend left] node {syn\_dcpt == 0 / end\_syndrome} (E1);

                \end{tikzpicture}
                \caption{Machine à état utilisée pour le calcul du syndrome}
                \label{fig:me_syndrome}
            \end{figure}

            \subsection{Définition des connexions entre l'UC et l'UT}

            \begin{figure}[H]
                \centering
                \begin{tikzpicture}[>=stealth, node distance=3cm, scale=0.8, every node/.style={scale=0.8}, circuit logic US]
                    \node[shape=ucsyndrome] at (5, 5) (ucsyndrome) {UC Syndrome};
                    \node[shape=utsyndrome] (utsyndrome) [below of=ucsyndrome] {UT Syndrome};

                    \draw[<-] (ucsyndrome.Start) -- +(-3, 0) node [anchor=east] {start\_syndrome};
                    \draw[<-] (ucsyndrome.Reset) -- +(-3, 0) node [anchor=east] {reset};
                    \draw[<-] (ucsyndrome.CLK) -- +(-3, 0) node [anchor=east] (CLK) {CLK};

                    \draw[->] (ucsyndrome.End) -- +(3, 0) node [anchor=west] {end\_syndrome};
                    \draw[->] (ucsyndrome.Calc) -- +(1, 0) node [anchor=west] {} -- +(1, -1.25) -- +(-6, -1.25) |- (utsyndrome.calc);
                    \draw[->] (ucsyndrome.Ld) -- +(1.25, 0) node [anchor=west] {} -- +(1.25, -2) -- +(-5.75, -2) |- (utsyndrome.ld);
                    \draw[->] (ucsyndrome.Clear) -- +(0.75, 0) node [anchor=west] {} -- +(0.75, -0.5) -- +(-6.25, -0.5) |- (utsyndrome.clear);

                    \draw[<-, double] (utsyndrome.Data) -- +(-3, 0) node [anchor=east] {Data\_in (FifoOut)};
                    \draw[<-] (utsyndrome.calc) -- +(-1, 0) node [anchor=east] {};
                    \draw[<-] (utsyndrome.CLK) -- +(-2, 0) node [anchor=east] {} |- (CLK);

                    \draw[->, double] (utsyndrome.Syndrome) -- +(3, 0) node [anchor=west] {syndrome};

                    \draw[dashed] (0,0) -- (10, 0) -- (10, 7) -- (0, 7) -- (0,0);
                \end{tikzpicture}

                \caption{Connexions entre l'UC et l'UT du calcul du syndrome}
                \label{fig:me_syndrome}
            \end{figure}


        \section{Look up table}
            \subsection{Unité de traitement}
            \begin{figure}[H]
                \centering
                \begin{tikzpicture}[>=stealth, node distance=3cm, scale=0.7, every node/.style={scale=0.7}, circuit logic US]
                    \tikzstyle{connectionpoint} = [circle, draw, fill=black, scale=0.5];
                    %\draw[help lines] (0, 0) grid (20,20);

                    \node[shape=counter] at (5,11) (p1counter) {P1};
                    \node[shape=counter] at (5,5) (p2counter) {P2 + 1};

                    \node[shape=lutcomponent] at (9, 8) (lut) {LUT};

                    \node[shape=dff] at (12, 14) (syn) {};

                    \node[xor gate, scale=1.5] at (12, 8) (xor) {};

                    \node[circle, draw] at (14, 9) (cmp1) {=};
                    \node[circle, draw] at (14, 7) (cmp2) {=};

                    \node[circle, draw] at (9, 11) (p1max) {=};
                    \node[circle, draw] at (9, 5) (p2max) {=};

                    \draw[<-, double] (syn.D) -- +(-9.5, 0) node [anchor=east] {Syndrome $[9:0]$};
                    \draw[<-] (syn.S) -- +(0, -0.25) -- +(-0.75, -0.25) |- (2, 13.5) node [anchor=east] {Ld\_syndrome};

                    \draw[<-] (p1counter.Inc) -- +(-2, 0) node [anchor=east] {Inc\_P1};
                    \draw[<-] (p1counter.Raz) -- +(-2, 0) node [anchor=east] {Raz};

                    \draw[<-] (p2counter.Inc) -- +(-2, 0) node [anchor=east] {Inc\_P2};
                    \draw[<-] (p2counter.Ld) -- +(-2, 0) node [anchor=east] {Ld\_P2};
                    \draw[<-] (p2counter.Raz) -- +(-2, 0) node [anchor=east] {Raz};

                    \draw[->, double] (p1counter.Q) -- +(1, 0) -- +(1, -4) -- +(-3, -4) |- (p2counter.Data);
                    \draw[->, double] (p1counter.Q) -- +(1, 0) -- +(1, -4) |- (lut.Pone);
                    \draw[->, double] (p1counter.Q) -- +(1, 0) |- (p1max.west);
                    \draw[->, double] (p1counter.Q) -| +(1, -2) -- +(10.25, -2) node[anchor=west] {P1};

                    \draw[->, double] (p2counter.Q) -- +(1, 0) |- (lut.Ptwo);
                    \draw[->, double] (p2counter.Q) -- +(1, 0) |- (p2max.west);
                    \draw[->, double] (p2counter.Q) -- +(10.25, 0) node[anchor=west] {P2};

                    \draw[->, double] (lut.Sone) -- +(1, 0) |- (xor.input 1);
                    \draw[->, double] (lut.Sone) -- +(1, 0) |- (cmp1.west);
                    \draw[->, double] (lut.Stwo) -- +(1, 0) |- (xor.input 2);

                    \draw[->, double] (xor.output) -- +(0.25, 0) |- (cmp2.west);

                    \draw[->, double] (syn.Q) -| (cmp1.north);
                    \draw[->, double] (syn.Q) -| (13.33, 7.5) -| (cmp2.north);

                    \draw[->] (cmp1.east) -- +(2, 0) node [anchor=west] {ERR1};
                    \draw[->] (cmp2.east) -- +(2, 0) node [anchor=west] {ERR2};
                    \draw[->] (p1max.east) -- +(7, 0) node [anchor=west] {P1\_max};
                    \draw[->] (p2max.east) -- +(7, 0) node [anchor=west] {P2\_max};
                    \draw[<-, double] (p1max.north) -- +(0, 1) node [anchor=south] {30};
                    \draw[<-, double] (p2max.south) -- +(0, -1) node [anchor=north] {31};

                    \node at (6, 12)[anchor=south west] {5};
                    \node at (6, 6)[anchor=south west] {5};
                    \node at (10, 8.5)[anchor=south west] {10};
                    \node at (10, 7.5)[anchor=south west] {10};

                    \draw[-,dashed] (2.5,2) -- (15.5, 2) -- (15.5, 16) -- (2.5, 16) -- (2.5, 2);

                    \node[connectionpoint] at (7, 11) {};
                    \node[connectionpoint] at (7, 10) {};
                    \node[connectionpoint] at (7, 8.5) {};
                    \node[connectionpoint] at (7, 6) {};
                    \node[connectionpoint] at (11, 8.5) {};
                    \node[connectionpoint] at (13.3, 14.4) {};

                \end{tikzpicture}
                \caption{Unité de traitement de la Look up table.}
                \label{fig:me_syndrome}
            \end{figure}

            \subsection{Unité de controle}

            \begin{figure}[H]
                \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=4cm]
                    \tikzstyle{every initial by arrow} = [initial text=reset, text=red, -, draw=red, decorate, decoration=zigzag]
                    \node[state, accepting, initial](E1){Idle};
                    \node[state](E2)[below of=E1]{Look up};

                    \path[->] (E1) edge [loop right] node {!start\_lut} (E1);
                    \path[->] (E1) edge node {start\_lut / raz, ld\_syndrome} (E2);

                    \path[->] (E2) edge [loop right] node  {p2\_max / inc\_p1, ld\_p2} (E2);
                    \path[->] (E2) edge [loop below] node {!p1\_max . !p2\_max / inc\_p2} (E2);

                    \draw[->] (node cs:name=E2,angle=205) parabola +(-1, 1.5) node[anchor=east] {err1 / end\_lut, ld\_err, err = "01"} parabola[bend at end] (node cs:name=E1,angle=250);
                    \draw[->] (node cs:name=E2,angle=180) parabola +(-1, 2) node[anchor=east] {err2 / end\_lut, ld\_err, err = "10"} parabola[bend at end] (node cs:name=E1,angle=225);
                    \draw[->] (node cs:name=E2,angle=155) parabola +(-1, 2.5) node[anchor=east] {p1\_max / end\_lut, ld\_err, err = "11"} parabola[bend at end] (node cs:name=E1,angle=200);
                    %\draw[-] (node cs:name=E2, angle=100) edge [bend left] node[pos=0.7, left] {err1 / end\_lut, ld\_err, err = "01"} (node cs:name=E1, angle=250);
                    %\draw[-] (node cs:name=E2, angle=125) edge [bend left] node[pos=0.5, left] {err2 / end\_lut, ld\_err, err = "10"} (node cs:name=E1, angle=225);
                    %\draw[-] (node cs:name=E2, angle=150) edge [bend left] node[pos=0.3, left] {p1\_max / end\_lut, ld\_err, err = "11"} (node cs:name=E1, angle=200);

                \end{tikzpicture}
                \caption{Machine à état utilisée pour le calcul du syndrome}
                \label{fig:me_syndrome}
            \end{figure}

            \subsection{Définition des connexions entre l'UC et l'UT}
            \begin{figure}[H]
                \centering
                \begin{tikzpicture}[>=stealth, scale=0.7, every node/.style={scale=0.7}, circuit logic US]
                    %\draw[help lines] (0, 0) grid (20,20);
                    \node[shape=uclut] at (5, 11) (uclut) {UC\_Lut};
                    \node[shape=utlut] at (5, 5) (utlut) {UT\_Lut};

                    \draw[->] (uclut.Raz) -- (utlut.Raz);
                    \draw[->] (uclut.LdPtwo) -- (utlut.LdPtwo);
                    \draw[->] (uclut.LdSyndrome) -- (utlut.LdSyndrome);
                    \draw[->] (uclut.IncPone) -- (utlut.IncPone);
                    \draw[->] (uclut.IncPtwo) -- (utlut.IncPtwo);

                    \draw[->] (utlut.PoneMax) -- (uclut.PoneMax);
                    \draw[->] (utlut.PtwoMax) -- (uclut.PtwoMax);
                    \draw[->] (utlut.ErrOne) -- (uclut.ErrOne);
                    \draw[->] (utlut.ErrTwo) -- (uclut.ErrTwo);

                    \draw[<-] (uclut.Start) -- +(-2, 0) node[anchor=east] {Start\_lut};
                    \draw[<-] (uclut.Reset) -- +(-2, 0) node[anchor=east] {Reset};

                    \draw[->] (uclut.End) -- +(2, 0) node[anchor=west] {End\_lut};
                    \draw[->, double] (uclut.Err) -- +(2, 0) node[anchor=west] {Err};
                    \draw[->] (uclut.LdErr) -- +(2, 0) node[anchor=west] {Ld\_Err};

                    \draw[->] (utlut.Pone) -- +(2, 0) node[anchor=west] {P1};
                    \draw[->] (utlut.Ptwo) -- +(2, 0) node[anchor=west] {P2};

                    \draw[<-, double] (utlut.Syndrome) -- +(-2,0) node[anchor=east] {Syndrome};

                    \node at (7.5, 11.6)[anchor=south west] {2};
                    \node at (2.5, 5)[anchor=south east] {10};

                    \draw[-,dashed] (1.5, 1.5) -- (8.5, 1.5) -- (8.5, 14.5) -- (1.5, 14.5) -- (1.5, 1.5);

                \end{tikzpicture}
                \caption{Connexions entre l'UC et l'UT de la look up table}
                \label{fig:me_syndrome}
            \end{figure}


        \section{Correcteur}
            \subsection{Unité de traitement}
            Le correcteur est basé sur un registre à décalage laissant passer
            un à un les 21 bits d'information du message. Ceux-ci seront
            corrigés, c'est à dire inversés, si leur position correspond avec
            les valeurs P1 ou P2, à condition que des erreurs soient
            effectivement présentes. La position du bit en cours de décalage
            est donnée par un registre de comptage, qui permet également à
            l'unité de contrôle de réaliser précisément 21 décalages. Le format
            de sortie désiré est par la suite créé et le nouveau message ainsi
            constitué sera maintenu jusqu'à ce qu'un autre cycle de la Look Up
            Table soit complété. Le schéma logique présentant ce foncitonnent
            est donné dans la figure~\ref{fig:ut_corr}

            \begin{figure}[H]
                \centering
                \begin{tikzpicture}[>=stealth, scale=0.6, every node/.style={scale=0.6}, circuit logic US]
                    \tikzstyle{connectionpoint} = [circle, draw, fill=black, scale=0.5];
                    %\draw[help lines] (0, 0) grid (20,20);

                    \node[shape=srr] at (3, 3) (srr) {};
                    \node[not gate] at (5, 2) (not) {};

                    \node[trapezium, draw, rotate=-90, scale=3] at (10, 2.5) (muxcorr) {};
                    \draw (muxcorr.south west) -- +(0,0) node[anchor=west] {0};
                    \draw (muxcorr.south east) -- +(0,0) node[anchor=west] {1};

                    \node[shape=counter] at (3, 10) (counter) {};

                    \node[circle, draw] at (6, 12) (cmp2) {=};
                    \node[circle, draw] at (6, 8) (cmp1) {=};

                    \node[trapezium, draw, rotate=-90, scale=3] at (9, 12) (muxcmp2) {};
                    \draw (muxcmp2.south west) -- +(0,0) node[anchor=west] {1};
                    \draw (muxcmp2.south east) -- +(0,0) node[anchor=west] {0};

                    \node[trapezium, draw, rotate=-90, scale=3] at (9, 8) (muxcmp1) {};
                    \draw (muxcmp1.south west) -- +(0,0) node[anchor=west] {0};
                    \draw (muxcmp1.south east) -- +(0,0) node[anchor=west] {1};

                    \node[or gate, rotate=-90] at (10, 6) (orcorr) {};
                    \node[or gate, rotate=-90] at (9, 14) (orsel) {};

                    \node[shape=pile] at (13, 2) (pile) {};

                    \draw[<-] (counter.Raz) -- +(-2, 0) node[anchor=east] {Raz};
                    \draw[<-, double] (srr.Din) -- +(-2, 0) node[anchor=east] {Din};
                    \draw[<-] (srr.Ld) -- +(-2, 0) node[anchor=east] {Ld\_buf};
                    \draw[<-] (srr.Shift) -- +(-2, 0) node[anchor=east] {Dec\_Buf};
                    \draw[<-] (pile.Raz) -| +(-0.25, -1) -- +(-12, -1) node[anchor=east] {Raz};
                    \draw[<-] (pile.Ld) -| +(-0.5, -1.25) -- +(-12, -1.25) node[anchor=east] {Ld\_Corr};
                    \draw[<-, double] (16, 5) |- (0, 15) node[anchor=east] (err) {Err};
                    \draw[<-] (orsel.input 1) -- +(0, 0.75);
                    \draw[<-] (orsel.input 2) -- +(0, 0.75);
                    \draw[<-] (muxcmp1.west) |- +(-2, 0.5) -- +(-2, 6.3);
                    \draw[<-, double] (cmp1.west) -| +(-0.65, -1) -- +(-5.65, -1)  node[anchor=east] {P1};
                    \draw[<-, double] (cmp2.west) -| +(-0.65, 1) -- +(-5.65, 1)  node[anchor=east] {P2};

                    \draw[->] (srr.Dout) -- +(5, 0) |- (muxcorr.south west);
                    \draw[->] (srr.Dout) -- +(0.5, 0) |- (not.input);
                    \draw[->] (not.output) -- +(3.55, 0) |- (muxcorr.south east);
                    \draw[->] (muxcorr.north) -- +(1, 0) |- (pile.In);

                    \draw[->] (muxcmp1.north) -| (orcorr.input 2);
                    \draw[->] (muxcmp2.north) -| (orcorr.input 1);
                    \draw[->] (orcorr.output) -- (muxcorr.west);

                    \draw[<-] (muxcmp1.south west) -- +(-1, 0) node[anchor=east] {0};
                    \draw[->] (cmp1.east) -- +(2, 0) |- (muxcmp1.south east);

                    \draw[<-] (muxcmp2.south east) -- +(-1, 0) node[anchor=east] {0};
                    \draw[->] (cmp2.east) -- +(2, 0) |- (muxcmp2.south west);

                    \draw[->] (orsel.output) -- (muxcmp2.west);
                    \draw[->, double] (counter.Q) -| (cmp2.south);
                    \draw[->, double] (counter.Q) -| (cmp1.north);
                    \draw[->, double] (counter.Q) -- +(2, 0) node [connectionpoint] {} -- +(16, 0) node[anchor=west] {Count};

                    \draw[<-] (counter.Inc) -- +(-0.5, 0) node[anchor=east] {1};

                    \draw[->, double] (14, 5) -- +(6, 0) node[anchor=west] {D\_corr\_out};

                    \draw[->, double] (pile.Dout) -| +(4, 3);

                    \draw[->, double] (17, 6) node[anchor=south] {0} -- +(0, -1);
                    \draw[->, double] (15, 6) node[anchor=south] {0} -- +(0, -1);

                    \node at (1, 15)[anchor=south west] {2};
                    \node at (1, 13)[anchor=south west] {5};
                    \node at (1, 7)[anchor=south west] {5};
                    \node at (1, 3.75)[anchor=south west] {32};
                    \node at (4, 11)[anchor=south west] {5};
                    \node at (9, 15)[anchor=north west] {[1]};
                    \node at (9, 15)[anchor=north east] {[0]};
                    \node at (7, 15)[anchor=north west] {[1]};
                    \node at (14, 2)[anchor=south west] {32};

                    \node at (15, 5)[anchor=south west] {\rotatebox{90}{6 $[31:26]$}};
                    \node at (16, 5)[anchor=south west] {\rotatebox{90}{2 $[25:24]$}};
                    \node at (17, 5)[anchor=south west] {\rotatebox{90}{3 $[23:21]$}};
                    \node at (18, 5)[anchor=north west] {\rotatebox{-90}{21 $[20:0]$}};

                    \draw[dashed] (1, 0) -- (19, 0) -- (19, 16) -- (1, 16) -- (1,0);


                \end{tikzpicture}
                \caption{Unité de traitement du correcteur}
                \label{fig:ut_corr}
            \end{figure}

            \subsection{Unité de contrôle}
            \begin{figure}[H]
                \centering
                \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=4cm]
                    \tikzstyle{every initial by arrow} = [initial text=reset, text=red, -, draw=red, decorate, decoration=zigzag]

                    \node[state, accepting, initial](E1){Idle};
                    \node[state](E2)[below of=E1]{Correction};
                    \node[right of=E1, right=-3.5cm]{Raz};

                    \path[->] (E1) edge [loop above] node {!start\_corr} (E1);
                    \path[->] (E1) edge node {start\_corr / ld\_buff} (E2);

                    \path[->] (E2) edge [loop right] node {Count != 21 / Dec\_buf, Ld\_corr} (E2);
                    \path[->] (E2) edge [bend left] node {Count = 21 / end\_corr} (E1);

                \end{tikzpicture}
                \caption{Machine à état utilisée pour la correction d'erreur}
                \label{fig:me_syndrome}
            \end{figure}

            \subsection{Définition des connexions entre l'UC et l'UT}

            \begin{figure}[H]
                \centering
                \begin{tikzpicture}[>=stealth, scale=0.6, every node/.style={scale=0.6}, circuit logic US]
                    %\draw[help lines] (0, 0) grid (20,20);

                    \node[shape=uccorr] at (5, 11) (uccorr) {UC\_Corr};
                    \node[shape=utcorr] at (5, 5) (utcorr) {UT\_Corr};

                    \draw[->](uccorr.Raz) -- (utcorr.Raz);
                    \draw[->](uccorr.DecBuf) -- (utcorr.DecBuf);
                    \draw[->](uccorr.LdBuf) -- (utcorr.LdBuf);
                    \draw[->](uccorr.LdCorr) -- (utcorr.LdCorr);

                    \draw[->](utcorr.Count) -- (uccorr.Count);

                    \draw[<-](uccorr.Start) -- +(-2, 0) node[anchor=east] {Start\_Corr};
                    \draw[<-](uccorr.Reset) -- +(-2, 0) node[anchor=east] {Reset};

                    \draw[->](uccorr.End) -- +(2, 0) node[anchor=west] {End\_corr};

                    \draw[<-,double](utcorr.Data) -- +(-2, 0) node[anchor=east] {FifoOut};
                    \draw[<-,double](utcorr.Err) -- +(-2, 0) node[anchor=east] {Err};
                    \draw[<-](utcorr.Pone) -- +(-2, 0) node[anchor=east] {P1};
                    \draw[<-](utcorr.Ptwo) -- +(-2, 0) node[anchor=east] {P2};
                    \draw[<-](utcorr.Reset) -- +(-2, 0) node[anchor=east] {Reset};
                    \draw[->](utcorr.DCorrOut) -- +(2, 0) node[anchor=west] {D\_Corr\_Out};

                    \draw[dashed](1.5, 1.5) -- (8.5, 1.5) -- (8.5, 14.5) -- (1.5, 14.5) -- (1.5, 1.5);

                \end{tikzpicture}
                \caption{Définition des connexions entre l'UC et l'UT du correcteur}
                \label{fig:me_syndrome}
            \end{figure}

        \section{Interface Avalon}
            Afin d'abstraire l'utilisation de l'interface avalon nous
            définissons un bloque responsable des gérer tous les registres et
            d'assembler les bus de donnée spécifié par le cahie des charges.

            \subsection{Vue extérieure}
            Du point de vue extérieur le bloque Avalon a plusieurs entrées
            sorties que l'on regroupe en deux types: Les entrées et sortites
            spécifié par l'interface avalon de nios et les entrée sorties
            spécialisés utilisée en interne par composant. Ces groupes sont
            présenté respectivement à gauche et droite du bloque avalon dont le
            schéma est présenté en figure~\ref{fig:int_avalon}.

            \begin{figure}[H]
                \centering
                \begin{tikzpicture}[>=stealth, scale=1, every node/.style={scale=1}, circuit logic US]

                    \node[shape=avalon] at (5, 5) (avalon) {Avalon};

                    \draw[<-] (avalon.Addr) -- +(-2, 0) node[anchor=east] {Addr};
                    \draw[<-] (avalon.R) -- +(-2, 0) node[anchor=east] {R};
                    \draw[<-] (avalon.W) -- +(-2, 0) node[anchor=east] {W};
                    \draw[<-] (avalon.Din) -- +(-2, 0) node[anchor=east] {D\_in};
                    \draw[->] (avalon.Dout) -- +(-2, 0) node[anchor=east] {D\_out};
                    \draw[->] (avalon.Irqn) -- +(-2, 0) node[anchor=east] {Irq\_n};
                    \draw[<-] (avalon.Reset) -- +(-2, 0) node[anchor=east] {Reset};

                    \draw[<-] (avalon.AskIrq) -- +(2, 0) node[anchor=west] {Ask\_irq};
                    \draw[<-] (avalon.CorrOut) -- +(2, 0) node[anchor=west] {CorrOut};
                    \draw[<-] (avalon.CorrOutLd) -- +(2, 0) node[anchor=west] {Corr\_out\_ld};
                    \draw[->] (avalon.FifoOut) -- +(2, 0) node[anchor=west] {FifoOut};
                    \draw[->] (avalon.Words) -- +(2, 0) node[anchor=west] {Words};
                    \draw[->] (avalon.Decode) -- +(2, 0) node[anchor=west] {Decode};

                \end{tikzpicture}
                \caption{Vue extérieur du block avalon}
                \label{fig:int_avalon}
            \end{figure}

            \subsection{Schéma fonctionnel}

            La fugure~\ref{fig:avalon_fonc} présente le shéma interne du bloque
            avalon. On y trouve en premier lieux tous les signaux d'entrées et
            sortie de l'interface Avalon Nios II à gauche et tous les signaux
            d'entrée sortie interne au bloque BCH à droite. Les liaisons se
            lisent de la même façon que dans Qsys. On trouve ensuite un
            décodeur d'adresse, block combinatoire qui permet de transformer
            l'adresse donné au block avalon en une selection de registre de
            status, controle ou donnée. La pile Fifo est intégrée au bloque
            avalon car elle sert à la communication bidirectionelle avec
            l'interface avalon. De pari avec la pile on trouve un compteur
            donnant le nombre de messages à traiter au démarage du BCH. Le
            compteur est nécéssaire car la pile d'envoi et de réception est
            partagée et qu'il n'est donc pas possible de ce fier au niveau de
            la Fifo. On trouve les registres permettant de conserver les
            informations des différents registres. Enfin on trouve l'assemblage
            des valeurs pour les bus de données et le multiplexeur qui permet de
            selectionner le bus relié au bus de données de l'interface avalon.

            \begin{figure}[H]
                \centering
                \begin{tikzpicture}[>=stealth, scale=0.5, every node/.style={scale=0.5}, circuit logic US]
                    \tikzstyle{connectionpoint} = [circle, draw, fill=black, scale=0.5];
                    %\draw[help lines] (0, 0) grid (30,40);

                    % Major busses

                    \foreach [count=\ni] \txt in {Addr, R, W, Din, Dout, Irq\_n, Reset}{
                        \draw[-] (-0.5 + 0.5*\ni, 0) -- (-0.5 + 0.5*\ni, 40) node[anchor=base] {\rotatebox{90}{\txt}};
                    }

                    \foreach [count=\ni] \txt in {Decod, Words, FifoOut, CorrOutLd, CorrOut, Ask\_irq}{
                        \draw[-] (30.5 - 0.5*\ni, 0) -- (30.5 - 0.5*\ni, 40) node[anchor=base] {\rotatebox{90}{\txt}};
                    }

                    \foreach [count=\ni] \txt in {Status, Control, Data}{
                        \draw[-] (9.5 + 0.5*\ni, 0) -- (9.5 + 0.5*\ni, 40) node[anchor=base] {\rotatebox{90}{\txt}};
                    }

                    \node[shape=decaddr] at (7, 37) (decaddr) {Dec Addr};
                    \draw[-] (decaddr.Addr) -- +(-5, 0) node[connectionpoint] {};
                    \draw[-] (decaddr.Status) -- +(1, 0) node[connectionpoint] {};
                    \draw[-] (decaddr.Control) -- +(1.5, 0) node[connectionpoint] {};
                    \draw[-] (decaddr.Data) -- +(2, 0) node[connectionpoint] {};

                    \node[shape=fifo] at (16, 30) (fifo) {Fifo};
                    \draw[-] (fifo.Dout) -- +(11, 0) node[connectionpoint] {};
                    \draw (fifo.Init) -- +(-11, 0) node[connectionpoint] {};

                    \node[trapezium, draw, rotate=-180, scale=3] at (13, 33) (muxfifo) {};
                    \draw (muxfifo.south west) -- +(0,0) node[anchor=north] {1};
                    \draw (muxfifo.south east) -- +(0,0) node[anchor=north] {0};
                    \draw (muxfifo.north) |- (fifo.Din);
                    \draw (muxfifo.south east) |- +(-11.1, 1) node[connectionpoint] {};
                    \draw (muxfifo.south west) |- +(14.6, 1) node[connectionpoint] {};
                    \draw (muxfifo.west) -- +(14.9, 0) node[connectionpoint] {};

                    \node[or gate, rotate=90] at (12, 28) (orfifow) {};
                    \node[or gate, rotate=90] at (13, 27) (orfifor) {};
                    \draw (fifo.W) -| (orfifow.output);
                    \draw (fifo.R) -| (orfifor.output);

                    \node[and gate] at (11.5, 26) (andfifow) {};
                    \node[and gate] at (12.5, 25) (andfifor) {};

                    \draw (orfifow.input 1) |- (andfifow.output);
                    \draw (orfifow.input 2) |- +(16.45, -0.25) node[connectionpoint] {};
                    \draw (orfifor.input 1) |- (andfifor.output);
                    \draw (orfifor.input 2) |- +(15.45, -0.25) node[connectionpoint] {};
                    \draw (andfifow.input 1) -- +(-0.27, 0) node[connectionpoint] {};
                    \draw (andfifow.input 2) -- +(-10.27, 0) node[connectionpoint] {};
                    \draw (andfifor.input 1) -- +(-1.37, 0) node[connectionpoint] {};
                    \draw (andfifor.input 2) -- +(-11.8, 0) node[connectionpoint] {};

                    \node[shape=dff] at(15, 22) (irqen) {IrqEn};
                    \node[and gate] at(14, 21) (andirqen) {};
                    \draw (andirqen) -| (irqen.S);
                    \draw (andirqen.input 1) -- +(-12.75, 0) node [connectionpoint] {};
                    \draw (andirqen.input 2) -- +(-3.35, 0) node [connectionpoint] {};
                    \draw (irqen.D) -- +(-13, 0) node [connectionpoint] {};
                    \draw (irqen.D) -- +(0,0) node[anchor=south east] {$[1]$};

                    \node[shape=dff] at(15, 19) (irq) {Irq};
                    \node[and gate] at (14, 20) (andirq) {};
                    \draw (andirq.output) -| (irq.R);
                    \draw (andirq.input 1) -- +(-13.3, 0) node [connectionpoint] {};
                    \draw (andirq.input 2) -- +(-3.85, 0) node [connectionpoint] {};
                    \draw (irq.D) -- +(-1, 0) node[anchor=east] {1};
                    \draw (irq.S) |- +(12.5, -0.25) node[connectionpoint] {};

                    \node [or gate, rotate=90] at (16, 23.5) (andirqn) {};
                    \draw (andirqn.input 1) |- (irqen.Qn);
                    \draw (andirqn.input 2) |- (irq.Qn);
                    \draw (andirqn.output) |- +(-13.5, 0.25) node [connectionpoint] {};

                    \node [shape=dff] at (15, 8) (decode) {Dec};
                    \draw (decode.Q) -- +(14.5, 0) node [connectionpoint] {};
                    \draw (decode.D) -- +(-13, 0) node [connectionpoint] {};
                    \draw (decode.D) -- +(0, 0) node [anchor=south east] {$[0]$};
                    \draw (decode.R) |- +(12.5, 0.25) node [connectionpoint] {};
                    \node [and gate, rotate=90] at (15, 6.5) (anddecode) {};
                    \draw (anddecode.output) -- (decode.S);
                    \draw (anddecode.input 1) |- +(-13.95, -0.25) node [connectionpoint] {};
                    \draw (anddecode.input 2) |- +(-4.55, -0.5) node [connectionpoint] {};

                    \node [shape=counter] at (15, 3) (words) {Words};
                    \draw (words.Q) -- +(13.5, 0) node [connectionpoint] {};
                    \draw (words.Raz) -| +(-0.5, -1.75) -- +(13.45, -1.75) node [connectionpoint] {};
                    \draw (words.Inc) -- +(-1, 0) node [and gate, anchor=output] (andwords) {};
                    \draw (andwords.input 1) -- +(-1.6, 0) node [connectionpoint] {};
                    \draw (andwords.input 2) -- +(-11.6, 0) node [connectionpoint] {};

                    \node [trapezium,draw,rotate=90,scale=4] at(15, 12) (muxdout) {};
                    \draw (muxdout.south west) -- +(0,0) node [anchor=east] {1X};
                    \draw (muxdout.south) -- +(0,0) node [anchor=east] {01};
                    \draw (muxdout.south east) -- +(0,0) node [anchor=east] {00};
                    \draw (muxdout.north) -- +(-12.5, 0) node [connectionpoint] {};
                    \draw (muxdout.east) |- +(-15, 0.25) node [connectionpoint] {};
                    \draw (muxdout.south west) -- +(13.5, 0) node [connectionpoint] {};
                    \draw (muxdout.south east) -| +(1.5, 4);
                    \draw (muxdout.south) -| +(5.5, 4.5);
                    \draw[->] (irq.Qn) -- +(3, 0) |- +(1.5, -2.6);
                    \draw[->] (fifo.Empty) -- +(0.75, 0) |- +(-1, -14.25);
                    \draw[->] (fifo.Full) -- +(1, 0) |- +(-1, -15.75);
                    \draw[<-] (17, 13) -- +(1, 0) node [anchor=west] {0};
                    \draw[<-] (21, 16) -- +(9, 0) node [connectionpoint] {};
                    \draw[->] (irqen.Q) -- +(6.5, 0) |- +(5.5, -8);
                    \draw[<-] (21, 13) -- +(1, 0) node[anchor=west] {0};

                \end{tikzpicture}
                \caption{Circuit logique du wrapper avalon}
                \label{fig:avalon_fonc}
            \end{figure}

    \chapter{Développement du code VHDL}

        \section{Calcul du syndrome}
            \paragraph{}
            Le calcul du syndrome n'a pas posé de problèmes d'implémentation.
            Les codes VHDL de l'unité de traitement, de l'unité de contrôle et
            l'assemblage est disponnible en annexe~\ref{ann:vhdl_syndrome}.

            \paragraph{}
            L'unité de contrôle embarque un décompteur pour attendre les 31
            coups d'horloge nécéssaire au calcul du syndrome par l'unité de
            traitement. Pour cela la partie décompteur est isolée dans un
            processus sensible uniquement à l'horloge. Le processus principal,
            gerrant les entrées et sorties en fonction des états, échange des
            ordres avec le processus de décomptage par l'intermédiaire de trois
            signaux internes:
            \begin{itemize}
                \item \verb$dec_init$ ordonne l'initialisation du décompteur.
                \item \verb$dec$ ordonne le décomptage.
                \item \verb$dec_flag$ drapeau informant que les 31 coups
                    d'horloges sont passés.
            \end{itemize}

            \paragraph{}
            La validation du calcul de syndrome est faite à partir des exemples
            du sujet. On place en entrée la valeur \verb$0x435A0BD5$ et on
            s'attend à obtenir un syndrome de 0 apres les 31 coups d'horloge.
            On place ensuite des valeurs ayant des erreur et on vérifie que les
            syndromes sont non null. La validité du syndrome dans la Look Up
            Table peut être vérifié manuellement et sera vérifiée
            automatiquement par la suite de test de l'assemblage syndrome/lut.

            % TODO Screenshot simulation

        \section{Look Up Table}
        \section{Correcteur}
        \section{Interface Avalon}
        \section{Assemblage des briques}

    \chapter{Synthèse logique et simulation structurelle}
    \chapter{Spécification du composant librairie}
    \chapter{Présentation de l'API c}

    Maintenant que le composant bibliothèque est implémenté et que le projet
    quartus est compilé et flashé il est nécéssaire d'implementer une api
    permettant d'utiliser le composant de facon assez confortable. L'api que
    nous proposont est assez riche.

    \section{Structure de donnée}

    Inclue en annexe~\ref{ann:api_h}, nous avons écrit une structure qui permet
    de récupérer une paire, message et erreur. Le message présent dans la
    sructure est le message corrigé si possible et le champ erreur permet de
    connaitre le nombre d'erreurs détectés.

    \section{Définition de l'API}

    L'api est définie en annexe~\ref{ann:api_h} mais est présentée plus en
    détail dans les sections suivantes.

    \subsection{Envoi et récupération de messages}

    Deux fonctins permettent l'échange de message à corriger et corrigé. Il
    s'agit de \verb$BCH_push_msg$ et \verb$BCH_pop_msg$. La première envoie un
    message à corriger sous forme d'entier non signé et la seconde récupère un
    message corrigé sous forme de structure \verb$bch_msg$.

    \subsection{Lecture du registre de status}

    La lecture du status ce fait avec la fonction \verb$BCH_read_status$ qui
    renvoi la valeur non signé présente sur le bus de status. L'utilisateur à
    alors la responsabilité d'utilisé les opérateurs logique «~et~» et «~ou~»
    afin de récupérer la valeur qui l'intéresse dans le status. Si une seule
    valeur l'intéresse, ou que le cout de lecture répété d'un registre n'est
    pas dérangeant l'utilisateur dispose de fonctions racourcis pui permettent
    d'acceder à une information ciblé du status~:
    \begin{itemize}
        \item \verb$BCH_is_full$ nous donne si la pile est pleinne
        \item \verb$BCH_is_empty$ nous donne si la pile est vide ou non
        \item \verb$BCH_is_irq$ nous donne si le traitement est terminé
    \end{itemize}

    \subsection{Lecture et écriture du registre de controle}

    De la même manière que pour le registre de status l'utilisteur dispose des
    fonctions \verb$BCH_read_ctrl$ et de \verb$BCH_write_ctrl$. Et de même il
    peut utiliser des fonctions racourcis pour lire et changer des valeurs sans
    avoir a manipuler manuellement le registre de controle. Les fonctions sont
    les suivantes~:
    \begin{itemize}
        \item \verb$BCH_is_irq_enabled$ qui permet de savoir si les irq sont activé ou non
        \item \verb$BCH_is_decoding$ qui permet de savoir si le decodeur est en marche
        \item \verb$BCH_ack_irq$ qui permet de désarmer une interruption
        \item \verb$BCH_enable_irq$ qui petmet d'activer les interruptions
        \item \verb$BCH_isable_irq$ qui permet de désactiver les interruptions
        \item \verb$BCH_start$ qui permet de lancer le décodage
    \end{itemize}


    \chapter{Application de démonstration}

    \begin{thebibliography}{99}
        %\bibitem{openlayers} Openlayers, \url{http://openlayers.org/}
    \end{thebibliography}

    \begin{appendices}

        \chapter{Code VHDL}

        \section{Calcul du syndrome}
        \label{ann:vhdl_syndrome}
        \subsection{Unité de traitement}
        \inputminted[firstline=0, lastline=51,breaklines]{VHDL}{../src/ut_syndrome.vhd}
        \subsection{Unité de controle}
        \inputminted[firstline=0, lastline=81,breaklines]{VHDL}{../src/uc_syndrome.vhd}
        \subsection{Assemblage UT/UC}
        \inputminted[firstline=0, lastline=44,breaklines]{VHDL}{../src/syndrome.vhd}

        \section{Look up table}
        \subsection{Unité de traitement}
        \inputminted[firstline=0, lastline=84,breaklines]{VHDL}{../src/ut_lut.vhd}
        \subsection{Unité de controle}
        \inputminted[firstline=0, lastline=72,breaklines]{VHDL}{../src/uc_lut.vhd}
        \subsection{Assemblage UT/UC}
        \inputminted[firstline=0, lastline=90,breaklines]{VHDL}{../src/lut.vhd}

        \section{Correcteur}
        \subsection{Unité de traitement}
        \inputminted[firstline=0, lastline=61,breaklines]{VHDL}{../src/ut_corr.vhd}
        \subsection{Unité de controle}
        \inputminted[firstline=0, lastline=53,breaklines]{VHDL}{../src/uc_corr.vhd}
        \subsection{Assemblage UT/UC}
        \inputminted[firstline=0, lastline=45,breaklines]{VHDL}{../src/corr.vhd}

        \section{Fifo}
        La pile fifo utilisée est celle proposé sur l'Ent.
        \inputminted[firstline=0, lastline=65,breaklines]{VHDL}{../src/fifo.vhd}

        \section{Interface Avalon}
        \inputminted[firstline=0, lastline=86,breaklines]{VHDL}{../src/avalon.vhd}

        \section{Unité de controle maitre}
        \inputminted[firstline=0, lastline=90,breaklines]{VHDL}{../src/uc_master.vhd}

        \section{Décodeur BCH complet}
        \inputminted[firstline=0, lastline=113,breaklines]{VHDL}{../src/bch.vhd}

        \chapter{Drivers et API}

        \section{Définition des registres}
        \inputminted[breaklines]{C}{../quartus/ip/BCH/inc/BCH_regs.h}

        \section{API}
        \subsection{Headers}
        \label{ann:api_h}
        \inputminted[breaklines]{C}{../quartus/ip/BCH/inc/BCHAPI.h}
        \subsection{Sources}
        \inputminted[breaklines]{C}{../quartus/ip/BCH/src/BCHAPI.c}

        \chapter{Code applicatif de démonstration}
        \inputminted[breaklines]{C}{../quartus/software/BCH/main.c}


    \end{appendices}

\end{document}
